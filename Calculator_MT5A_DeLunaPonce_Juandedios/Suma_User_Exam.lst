CCS PCM C Compiler, Version 4.104, 5967               10-jul.-19 13:58

               Filename: C:\Users\student\Desktop\Practicas_Juandedios\Suma_User_Exam.lst

               ROM used: 3786 words (46%)
                         Largest free fragment is 2048
               RAM used: 74 (20%) at main() level
                         146 (40%) worst case
               Stack:    5 locations

*
0000:  MOVLW  0A
0001:  MOVWF  0A
0002:  GOTO   24C
0003:  NOP
.................... #include <16f877a.h> 
.................... //////// Standard Header file for the PIC16F877A device //////////////// 
.................... #device PIC16F877A 
.................... #list 
....................  
.................... #use delay(clock=16M) 
*
008C:  MOVLW  A9
008D:  MOVWF  04
008E:  BCF    03.7
008F:  MOVF   00,W
0090:  BTFSC  03.2
0091:  GOTO   0A0
0092:  MOVLW  05
0093:  MOVWF  78
0094:  CLRF   77
0095:  DECFSZ 77,F
0096:  GOTO   095
0097:  DECFSZ 78,F
0098:  GOTO   094
0099:  MOVLW  2E
009A:  MOVWF  77
009B:  DECFSZ 77,F
009C:  GOTO   09B
009D:  GOTO   09E
009E:  DECFSZ 00,F
009F:  GOTO   092
00A0:  RETURN
.................... #include <lcd.c> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                     The following have special meaning:               //// 
.................... ////                      \f  Clear display                                //// 
.................... ////                      \n  Go to start of second line                   //// 
.................... ////                      \b  Move back one position                       //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    BOOLEAN enable;           // on to an I/O port to gain 
....................    BOOLEAN rs;               // access to the LCD pins. 
....................    BOOLEAN rw;               // The bits are allocated from 
....................    BOOLEAN unused;           // low order up.  ENABLE will 
....................    int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... BYTE const LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................  
.................... BYTE lcd_read_nibble(void); 
....................  
.................... BYTE lcd_read_byte(void) 
.................... { 
....................    BYTE low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
....................    output_float(LCD_DATA5); 
....................    output_float(LCD_DATA6); 
....................    output_float(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0xF; 
*
00BA:  MOVLW  0F
00BB:  BSF    03.5
00BC:  ANDWF  08,W
00BD:  IORLW  F0
00BE:  MOVWF  08
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
00BF:  BCF    03.5
00C0:  BSF    08.2
....................    delay_cycles(1); 
00C1:  NOP
....................    lcd_output_enable(1); 
00C2:  BSF    08.0
....................    delay_cycles(1); 
00C3:  NOP
....................    high = lcd_read_nibble(); 
00C4:  CALL   0B3
00C5:  MOVF   78,W
00C6:  BSF    03.5
00C7:  MOVWF  30
....................        
....................    lcd_output_enable(0); 
00C8:  BCF    03.5
00C9:  BCF    08.0
....................    delay_cycles(1); 
00CA:  NOP
....................    lcd_output_enable(1); 
00CB:  BSF    08.0
....................    delay_us(1); 
00CC:  GOTO   0CD
00CD:  GOTO   0CE
....................    low = lcd_read_nibble(); 
00CE:  CALL   0B3
00CF:  MOVF   78,W
00D0:  BSF    03.5
00D1:  MOVWF  2F
....................        
....................    lcd_output_enable(0); 
00D2:  BCF    03.5
00D3:  BCF    08.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
00D4:  MOVLW  0F
00D5:  BSF    03.5
00D6:  ANDWF  08,W
00D7:  MOVWF  08
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
00D8:  SWAPF  30,W
00D9:  MOVWF  77
00DA:  MOVLW  F0
00DB:  ANDWF  77,F
00DC:  MOVF   77,W
00DD:  IORWF  2F,W
00DE:  MOVWF  78
.................... } 
....................  
.................... BYTE lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    BYTE n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
....................    n |= input(LCD_DATA5) << 1; 
....................    n |= input(LCD_DATA6) << 2; 
....................    n |= input(LCD_DATA7) << 3; 
....................     
....................    return(n); 
....................   #else 
....................    return(lcd.data); 
*
00B3:  MOVF   08,W
00B4:  MOVWF  77
00B5:  SWAPF  08,W
00B6:  ANDLW  0F
00B7:  MOVWF  78
....................   #endif 
.................... } 
00B8:  RETURN
....................  
.................... void lcd_send_nibble(BYTE n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
....................   #else       
....................    lcdlat.data = n; 
*
00A1:  BSF    03.5
00A2:  SWAPF  30,W
00A3:  ANDLW  F0
00A4:  MOVWF  77
00A5:  MOVLW  0F
00A6:  BCF    03.5
00A7:  ANDWF  08,W
00A8:  IORWF  77,W
00A9:  MOVWF  08
....................   #endif 
....................        
....................    delay_cycles(1); 
00AA:  NOP
....................    lcd_output_enable(1); 
00AB:  BSF    08.0
....................    delay_us(2); 
00AC:  MOVLW  02
00AD:  MOVWF  77
00AE:  DECFSZ 77,F
00AF:  GOTO   0AE
00B0:  NOP
....................    lcd_output_enable(0); 
00B1:  BCF    08.0
.................... } 
00B2:  RETURN
....................  
.................... void lcd_send_byte(BYTE address, BYTE n) 
.................... { 
....................    lcd_output_rs(0); 
*
00B9:  BCF    08.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
00DF:  MOVF   78,W
00E0:  MOVWF  2F
00E1:  BTFSS  2F.7
00E2:  GOTO   0E5
00E3:  BCF    03.5
00E4:  GOTO   0BA
....................    lcd_output_rs(address); 
00E5:  BTFSC  2D.0
00E6:  GOTO   0EA
00E7:  BCF    03.5
00E8:  BCF    08.1
00E9:  BSF    03.5
00EA:  BTFSS  2D.0
00EB:  GOTO   0EF
00EC:  BCF    03.5
00ED:  BSF    08.1
00EE:  BSF    03.5
....................    delay_cycles(1); 
00EF:  NOP
....................    lcd_output_rw(0); 
00F0:  BCF    03.5
00F1:  BCF    08.2
....................    delay_cycles(1); 
00F2:  NOP
....................    lcd_output_enable(0); 
00F3:  BCF    08.0
....................    lcd_send_nibble(n >> 4); 
00F4:  BSF    03.5
00F5:  SWAPF  2E,W
00F6:  MOVWF  2F
00F7:  MOVLW  0F
00F8:  ANDWF  2F,F
00F9:  MOVF   2F,W
00FA:  MOVWF  30
00FB:  BCF    03.5
00FC:  CALL   0A1
....................    lcd_send_nibble(n & 0xf); 
00FD:  BSF    03.5
00FE:  MOVF   2E,W
00FF:  ANDLW  0F
0100:  MOVWF  2F
0101:  MOVWF  30
0102:  BCF    03.5
0103:  CALL   0A1
.................... } 
0104:  RETURN
....................  
.................... void lcd_init(void)  
.................... { 
....................    BYTE i; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
0105:  MOVLW  0F
0106:  BSF    03.5
0107:  ANDWF  08,W
0108:  MOVWF  08
....................   #endif 
....................    lcd_enable_tris(); 
0109:  BCF    08.0
....................    lcd_rs_tris(); 
010A:  BCF    08.1
....................    lcd_rw_tris(); 
010B:  BCF    08.2
....................  #endif 
....................  
....................    lcd_output_rs(0); 
010C:  BCF    03.5
010D:  BCF    08.1
....................    lcd_output_rw(0); 
010E:  BCF    08.2
....................    lcd_output_enable(0); 
010F:  BCF    08.0
....................      
....................    delay_ms(15); 
0110:  MOVLW  0F
0111:  BSF    03.5
0112:  MOVWF  29
0113:  BCF    03.5
0114:  CALL   08C
....................    for(i=1;i<=3;++i) 
0115:  MOVLW  01
0116:  MOVWF  71
0117:  MOVF   71,W
0118:  SUBLW  03
0119:  BTFSS  03.0
011A:  GOTO   127
....................    { 
....................        lcd_send_nibble(3); 
011B:  MOVLW  03
011C:  BSF    03.5
011D:  MOVWF  30
011E:  BCF    03.5
011F:  CALL   0A1
....................        delay_ms(5); 
0120:  MOVLW  05
0121:  BSF    03.5
0122:  MOVWF  29
0123:  BCF    03.5
0124:  CALL   08C
....................    } 
0125:  INCF   71,F
0126:  GOTO   117
....................      
....................    lcd_send_nibble(2); 
0127:  MOVLW  02
0128:  BSF    03.5
0129:  MOVWF  30
012A:  BCF    03.5
012B:  CALL   0A1
....................    for(i=0;i<=3;++i) 
012C:  CLRF   71
012D:  MOVF   71,W
012E:  SUBLW  03
012F:  BTFSS  03.0
0130:  GOTO   13C
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
0131:  MOVF   71,W
0132:  CALL   004
0133:  MOVWF  72
0134:  BSF    03.5
0135:  CLRF   2D
0136:  MOVF   72,W
0137:  MOVWF  2E
0138:  BCF    03.5
0139:  CALL   0B9
013A:  INCF   71,F
013B:  GOTO   12D
.................... } 
013C:  BSF    0A.3
013D:  BCF    0A.4
013E:  GOTO   262 (RETURN)
....................  
.................... void lcd_gotoxy(BYTE x, BYTE y) 
.................... { 
....................    BYTE address; 
....................  
....................    if(y!=1) 
*
0142:  BSF    03.5
0143:  DECFSZ 2A,W
0144:  GOTO   146
0145:  GOTO   149
....................       address=LCD_LINE_TWO; 
0146:  MOVLW  40
0147:  MOVWF  2B
....................    else 
0148:  GOTO   14A
....................       address=0; 
0149:  CLRF   2B
....................       
....................    address+=x-1; 
014A:  MOVLW  01
014B:  SUBWF  29,W
014C:  ADDWF  2B,F
....................    lcd_send_byte(0,0x80|address); 
014D:  MOVF   2B,W
014E:  IORLW  80
014F:  MOVWF  2C
0150:  CLRF   2D
0151:  MOVF   2C,W
0152:  MOVWF  2E
0153:  BCF    03.5
0154:  CALL   0B9
.................... } 
0155:  RETURN
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
....................    { 
0156:  BSF    03.5
0157:  MOVF   28,W
0158:  XORLW  0C
0159:  BCF    03.5
015A:  BTFSC  03.2
015B:  GOTO   163
015C:  XORLW  06
015D:  BTFSC  03.2
015E:  GOTO   16F
015F:  XORLW  02
0160:  BTFSC  03.2
0161:  GOTO   177
0162:  GOTO   17E
....................       case '\f'   :  lcd_send_byte(0,1); 
0163:  BSF    03.5
0164:  CLRF   2D
0165:  MOVLW  01
0166:  MOVWF  2E
0167:  BCF    03.5
0168:  CALL   0B9
....................                      delay_ms(2); 
0169:  MOVLW  02
016A:  BSF    03.5
016B:  MOVWF  29
016C:  BCF    03.5
016D:  CALL   08C
....................                      break; 
016E:  GOTO   186
....................                       
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
016F:  MOVLW  01
0170:  BSF    03.5
0171:  MOVWF  29
0172:  MOVLW  02
0173:  MOVWF  2A
0174:  BCF    03.5
0175:  CALL   142
0176:  GOTO   186
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
0177:  BSF    03.5
0178:  CLRF   2D
0179:  MOVLW  10
017A:  MOVWF  2E
017B:  BCF    03.5
017C:  CALL   0B9
017D:  GOTO   186
....................       
....................       default     : lcd_send_byte(1,c);     break; 
017E:  MOVLW  01
017F:  BSF    03.5
0180:  MOVWF  2D
0181:  MOVF   28,W
0182:  MOVWF  2E
0183:  BCF    03.5
0184:  CALL   0B9
0185:  GOTO   186
....................    } 
.................... } 
0186:  RETURN
....................   
.................... char lcd_getc(BYTE x, BYTE y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
*
024E:  BSF    03.5
024F:  MOVF   4C,W
0250:  MOVWF  4E
....................    for(su=s;0<n;++su,--n) 
0251:  MOVF   4B,W
0252:  MOVWF  50
0253:  MOVF   4A,W
0254:  MOVWF  4F
0255:  MOVF   4D,W
0256:  SUBLW  00
0257:  BTFSC  03.0
0258:  GOTO   26E
....................       if(*su==uc) 
0259:  MOVF   50,W
025A:  MOVWF  7A
025B:  MOVF   4F,W
025C:  MOVWF  04
025D:  BCF    03.7
025E:  BTFSC  7A.0
025F:  BSF    03.7
0260:  MOVF   4E,W
0261:  SUBWF  00,W
0262:  BTFSS  03.2
0263:  GOTO   269
....................       return su; 
0264:  MOVF   4F,W
0265:  MOVWF  78
0266:  MOVF   50,W
0267:  MOVWF  79
0268:  GOTO   271
0269:  INCF   4F,F
026A:  BTFSC  03.2
026B:  INCF   50,F
026C:  DECF   4D,F
026D:  GOTO   255
....................    return NULL; 
026E:  MOVLW  00
026F:  MOVWF  78
0270:  MOVWF  79
.................... } 
0271:  BCF    03.5
0272:  RETURN
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
0A57:  BCF    03.5
0A58:  CLRF   20
0A59:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
*
0800:  CLRF   7E
0801:  CLRF   7D
0802:  CLRF   7C
0803:  MOVLW  7F
0804:  MOVWF  7B
0805:  BSF    03.5
0806:  CLRF   23
0807:  CLRF   22
0808:  CLRF   21
0809:  CLRF   20
080A:  BSF    75.0
080B:  BCF    75.1
080C:  BCF    75.2
080D:  CLRF   24
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
080E:  MOVF   71,W
080F:  IORWF  72,W
0810:  BTFSS  03.2
0811:  GOTO   017
....................       return 0; 
0812:  CLRF   77
0813:  CLRF   78
0814:  CLRF   79
0815:  CLRF   7A
0816:  GOTO   141
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
0817:  MOVF   24,W
0818:  INCF   24,F
0819:  ADDWF  71,W
081A:  MOVWF  04
081B:  BCF    03.7
081C:  BTFSC  72.0
081D:  BSF    03.7
081E:  MOVF   00,W
081F:  MOVWF  76
0820:  MOVF   76,F
0821:  BTFSC  03.2
0822:  GOTO   0FB
....................    { 
....................       if (skip && !isspace(c)) 
0823:  BTFSS  75.0
0824:  GOTO   037
0825:  MOVF   76,W
0826:  SUBLW  20
0827:  BTFSC  03.2
0828:  GOTO   037
....................       { 
....................          skip = 0; 
0829:  BCF    75.0
....................          if (c == '+') 
082A:  MOVF   76,W
082B:  SUBLW  2B
082C:  BTFSS  03.2
082D:  GOTO   031
....................          { 
....................             sign = 0; 
082E:  BCF    75.1
....................             continue; 
082F:  GOTO   0F1
....................          }             
....................          else if (c == '-') 
0830:  GOTO   037
0831:  MOVF   76,W
0832:  SUBLW  2D
0833:  BTFSS  03.2
0834:  GOTO   037
....................          { 
....................             sign = 1; 
0835:  BSF    75.1
....................             continue; 
0836:  GOTO   0F1
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
0837:  BTFSC  75.0
0838:  GOTO   041
0839:  MOVF   76,W
083A:  SUBLW  2E
083B:  BTFSS  03.2
083C:  GOTO   041
083D:  BTFSC  75.2
083E:  GOTO   041
....................          point = 1; 
083F:  BSF    75.2
....................       else if (!skip && isdigit(c)) 
0840:  GOTO   0F1
0841:  BTFSC  75.0
0842:  GOTO   0EF
0843:  MOVF   76,W
0844:  SUBLW  2F
0845:  BTFSC  03.0
0846:  GOTO   0EF
0847:  MOVF   76,W
0848:  SUBLW  39
0849:  BTFSS  03.0
084A:  GOTO   0EF
....................       { 
....................          c -= '0'; 
084B:  MOVLW  30
084C:  SUBWF  76,F
....................          if (point) 
084D:  BTFSS  75.2
084E:  GOTO   0AD
....................          { 
....................             pow10 = pow10 * 10.0; 
084F:  MOVF   7E,W
0850:  MOVWF  2B
0851:  MOVF   7D,W
0852:  MOVWF  2A
0853:  MOVF   7C,W
0854:  MOVWF  29
0855:  MOVF   7B,W
0856:  MOVWF  28
0857:  CLRF   2F
0858:  CLRF   2E
0859:  MOVLW  20
085A:  MOVWF  2D
085B:  MOVLW  82
085C:  MOVWF  2C
085D:  BCF    0A.3
085E:  BCF    03.5
085F:  CALL   483
0860:  BSF    0A.3
0861:  MOVF   7A,W
0862:  MOVWF  7E
0863:  MOVF   79,W
0864:  MOVWF  7D
0865:  MOVF   78,W
0866:  MOVWF  7C
0867:  MOVF   77,W
0868:  MOVWF  7B
....................             result += (float)c / pow10;    
0869:  BSF    03.5
086A:  CLRF   2C
086B:  MOVF   76,W
086C:  MOVWF  2B
086D:  BCF    0A.3
086E:  BCF    03.5
086F:  CALL   4FA
0870:  BSF    0A.3
0871:  MOVF   77,W
0872:  BSF    03.5
0873:  MOVWF  25
0874:  MOVF   78,W
0875:  MOVWF  26
0876:  MOVF   79,W
0877:  MOVWF  27
0878:  MOVF   7A,W
0879:  MOVWF  28
087A:  MOVWF  2E
087B:  MOVF   27,W
087C:  MOVWF  2D
087D:  MOVF   26,W
087E:  MOVWF  2C
087F:  MOVF   25,W
0880:  MOVWF  2B
0881:  MOVF   7E,W
0882:  MOVWF  32
0883:  MOVF   7D,W
0884:  MOVWF  31
0885:  MOVF   7C,W
0886:  MOVWF  30
0887:  MOVF   7B,W
0888:  MOVWF  2F
0889:  BCF    0A.3
088A:  BCF    03.5
088B:  CALL   519
088C:  BSF    0A.3
088D:  BCF    03.1
088E:  BSF    03.5
088F:  MOVF   23,W
0890:  MOVWF  2E
0891:  MOVF   22,W
0892:  MOVWF  2D
0893:  MOVF   21,W
0894:  MOVWF  2C
0895:  MOVF   20,W
0896:  MOVWF  2B
0897:  MOVF   7A,W
0898:  MOVWF  32
0899:  MOVF   79,W
089A:  MOVWF  31
089B:  MOVF   78,W
089C:  MOVWF  30
089D:  MOVF   77,W
089E:  MOVWF  2F
089F:  BCF    0A.3
08A0:  BCF    03.5
08A1:  CALL   5E5
08A2:  BSF    0A.3
08A3:  MOVF   7A,W
08A4:  BSF    03.5
08A5:  MOVWF  23
08A6:  MOVF   79,W
08A7:  MOVWF  22
08A8:  MOVF   78,W
08A9:  MOVWF  21
08AA:  MOVF   77,W
08AB:  MOVWF  20
....................          } 
....................          else 
08AC:  GOTO   0EE
....................          { 
....................             result = 10.0 * result + (float)c; 
08AD:  CLRF   2B
08AE:  CLRF   2A
08AF:  MOVLW  20
08B0:  MOVWF  29
08B1:  MOVLW  82
08B2:  MOVWF  28
08B3:  MOVF   23,W
08B4:  MOVWF  2F
08B5:  MOVF   22,W
08B6:  MOVWF  2E
08B7:  MOVF   21,W
08B8:  MOVWF  2D
08B9:  MOVF   20,W
08BA:  MOVWF  2C
08BB:  BCF    0A.3
08BC:  BCF    03.5
08BD:  CALL   483
08BE:  BSF    0A.3
08BF:  MOVF   77,W
08C0:  BSF    03.5
08C1:  MOVWF  25
08C2:  MOVF   78,W
08C3:  MOVWF  26
08C4:  MOVF   79,W
08C5:  MOVWF  27
08C6:  MOVF   7A,W
08C7:  MOVWF  28
08C8:  CLRF   2C
08C9:  MOVF   76,W
08CA:  MOVWF  2B
08CB:  BCF    0A.3
08CC:  BCF    03.5
08CD:  CALL   4FA
08CE:  BSF    0A.3
08CF:  BCF    03.1
08D0:  BSF    03.5
08D1:  MOVF   28,W
08D2:  MOVWF  2E
08D3:  MOVF   27,W
08D4:  MOVWF  2D
08D5:  MOVF   26,W
08D6:  MOVWF  2C
08D7:  MOVF   25,W
08D8:  MOVWF  2B
08D9:  MOVF   7A,W
08DA:  MOVWF  32
08DB:  MOVF   79,W
08DC:  MOVWF  31
08DD:  MOVF   78,W
08DE:  MOVWF  30
08DF:  MOVF   77,W
08E0:  MOVWF  2F
08E1:  BCF    0A.3
08E2:  BCF    03.5
08E3:  CALL   5E5
08E4:  BSF    0A.3
08E5:  MOVF   7A,W
08E6:  BSF    03.5
08E7:  MOVWF  23
08E8:  MOVF   79,W
08E9:  MOVWF  22
08EA:  MOVF   78,W
08EB:  MOVWF  21
08EC:  MOVF   77,W
08ED:  MOVWF  20
....................          } 
....................       } 
....................       else if (!skip) 
08EE:  GOTO   0F1
08EF:  BTFSS  75.0
....................          break; 
08F0:  GOTO   0FB
....................    } 
08F1:  MOVF   24,W
08F2:  INCF   24,F
08F3:  ADDWF  71,W
08F4:  MOVWF  04
08F5:  BCF    03.7
08F6:  BTFSC  72.0
08F7:  BSF    03.7
08F8:  MOVF   00,W
08F9:  MOVWF  76
08FA:  GOTO   020
....................  
....................    if (sign) 
08FB:  BTFSS  75.1
08FC:  GOTO   118
....................       result = -1*result; 
08FD:  CLRF   2B
08FE:  CLRF   2A
08FF:  MOVLW  80
0900:  MOVWF  29
0901:  MOVLW  7F
0902:  MOVWF  28
0903:  MOVF   23,W
0904:  MOVWF  2F
0905:  MOVF   22,W
0906:  MOVWF  2E
0907:  MOVF   21,W
0908:  MOVWF  2D
0909:  MOVF   20,W
090A:  MOVWF  2C
090B:  BCF    0A.3
090C:  BCF    03.5
090D:  CALL   483
090E:  BSF    0A.3
090F:  MOVF   7A,W
0910:  BSF    03.5
0911:  MOVWF  23
0912:  MOVF   79,W
0913:  MOVWF  22
0914:  MOVF   78,W
0915:  MOVWF  21
0916:  MOVF   77,W
0917:  MOVWF  20
....................        
....................    if(endptr) 
0918:  MOVF   73,W
0919:  IORWF  74,W
091A:  BTFSC  03.2
091B:  GOTO   139
....................    { 
....................       if (ptr) { 
091C:  MOVF   24,F
091D:  BTFSC  03.2
091E:  GOTO   12E
....................          ptr--; 
091F:  DECF   24,F
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
0920:  MOVF   73,W
0921:  MOVWF  04
0922:  BCF    03.7
0923:  BTFSC  74.0
0924:  BSF    03.7
0925:  MOVF   24,W
0926:  ADDWF  71,W
0927:  MOVWF  00
0928:  INCF   04,F
0929:  MOVF   72,W
092A:  MOVWF  00
092B:  BTFSC  03.0
092C:  INCF   00,F
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
092D:  GOTO   139
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
092E:  MOVF   73,W
092F:  MOVWF  04
0930:  BCF    03.7
0931:  BTFSC  74.0
0932:  BSF    03.7
0933:  INCF   04,F
0934:  MOVF   72,W
0935:  MOVWF  00
0936:  DECF   04,F
0937:  MOVF   71,W
0938:  MOVWF  00
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
0939:  MOVF   20,W
093A:  MOVWF  77
093B:  MOVF   21,W
093C:  MOVWF  78
093D:  MOVF   22,W
093E:  MOVWF  79
093F:  MOVF   23,W
0940:  MOVWF  7A
.................... } 
0941:  BCF    03.5
0942:  RETURN
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
*
0273:  BSF    03.5
0274:  CLRF   23
0275:  CLRF   22
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
0276:  MOVLW  30
0277:  MOVWF  24
0278:  MOVLW  31
0279:  MOVWF  25
027A:  MOVLW  32
027B:  MOVWF  26
027C:  MOVLW  33
027D:  MOVWF  27
027E:  MOVLW  34
027F:  MOVWF  28
0280:  MOVLW  35
0281:  MOVWF  29
0282:  MOVLW  36
0283:  MOVWF  2A
0284:  MOVLW  37
0285:  MOVWF  2B
0286:  MOVLW  38
0287:  MOVWF  2C
0288:  MOVLW  39
0289:  MOVWF  2D
028A:  MOVLW  61
028B:  MOVWF  2E
028C:  MOVLW  62
028D:  MOVWF  2F
028E:  MOVLW  63
028F:  MOVWF  30
0290:  MOVLW  64
0291:  MOVWF  31
0292:  MOVLW  65
0293:  MOVWF  32
0294:  MOVLW  66
0295:  MOVWF  33
0296:  MOVLW  67
0297:  MOVWF  34
0298:  MOVLW  68
0299:  MOVWF  35
029A:  MOVLW  69
029B:  MOVWF  36
029C:  MOVLW  6A
029D:  MOVWF  37
029E:  MOVLW  6B
029F:  MOVWF  38
02A0:  MOVLW  6C
02A1:  MOVWF  39
02A2:  MOVLW  6D
02A3:  MOVWF  3A
02A4:  MOVLW  6E
02A5:  MOVWF  3B
02A6:  MOVLW  6F
02A7:  MOVWF  3C
02A8:  MOVLW  70
02A9:  MOVWF  3D
02AA:  MOVLW  71
02AB:  MOVWF  3E
02AC:  MOVLW  73
02AD:  MOVWF  3F
02AE:  MOVLW  74
02AF:  MOVWF  40
02B0:  MOVLW  75
02B1:  MOVWF  41
02B2:  MOVLW  76
02B3:  MOVWF  42
02B4:  MOVLW  77
02B5:  MOVWF  43
02B6:  MOVLW  78
02B7:  MOVWF  44
02B8:  MOVLW  79
02B9:  MOVWF  45
02BA:  MOVLW  7A
02BB:  MOVWF  46
02BC:  CLRF   47
....................    for(sc=s;isspace(*sc);++sc); 
02BD:  MOVF   72,W
02BE:  MOVWF  7C
02BF:  MOVF   71,W
02C0:  MOVWF  7B
02C1:  MOVF   7C,W
02C2:  MOVWF  7A
02C3:  MOVF   7B,W
02C4:  MOVWF  04
02C5:  BCF    03.7
02C6:  BTFSC  7A.0
02C7:  BSF    03.7
02C8:  MOVF   00,W
02C9:  SUBLW  20
02CA:  BTFSS  03.2
02CB:  GOTO   2D0
02CC:  INCF   7B,F
02CD:  BTFSC  03.2
02CE:  INCF   7C,F
02CF:  GOTO   2C1
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
02D0:  MOVF   7C,W
02D1:  MOVWF  7A
02D2:  MOVF   7B,W
02D3:  MOVWF  04
02D4:  BCF    03.7
02D5:  BTFSC  7C.0
02D6:  BSF    03.7
02D7:  MOVF   00,W
02D8:  SUBLW  2D
02D9:  BTFSC  03.2
02DA:  GOTO   2E6
02DB:  MOVF   7C,W
02DC:  MOVWF  7A
02DD:  MOVF   7B,W
02DE:  MOVWF  04
02DF:  BCF    03.7
02E0:  BTFSC  7C.0
02E1:  BSF    03.7
02E2:  MOVF   00,W
02E3:  SUBLW  2B
02E4:  BTFSS  03.2
02E5:  GOTO   2F2
02E6:  MOVF   7C,W
02E7:  MOVWF  7A
02E8:  MOVF   7B,W
02E9:  INCF   7B,F
02EA:  BTFSC  03.2
02EB:  INCF   7C,F
02EC:  MOVWF  04
02ED:  BCF    03.7
02EE:  BTFSC  7A.0
02EF:  BSF    03.7
02F0:  MOVF   00,W
02F1:  GOTO   2F3
02F2:  MOVLW  2B
02F3:  MOVWF  76
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
02F4:  MOVF   76,W
02F5:  SUBLW  2D
02F6:  BTFSC  03.2
02F7:  GOTO   303
02F8:  BTFSC  75.7
02F9:  GOTO   303
02FA:  DECFSZ 75,W
02FB:  GOTO   2FD
02FC:  GOTO   303
02FD:  BTFSC  75.7
02FE:  GOTO   305
02FF:  MOVF   75,W
0300:  SUBLW  24
0301:  BTFSC  03.0
0302:  GOTO   305
....................    goto StrtoulGO; 
0303:  GOTO   45B
....................  
....................    else if (base) 
0304:  GOTO   39B
0305:  MOVF   75,F
0306:  BTFSC  03.2
0307:  GOTO   360
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
0308:  MOVF   75,W
0309:  SUBLW  10
030A:  BTFSS  03.2
030B:  GOTO   32F
030C:  MOVF   7C,W
030D:  MOVWF  7A
030E:  MOVF   7B,W
030F:  MOVWF  04
0310:  BCF    03.7
0311:  BTFSC  7A.0
0312:  BSF    03.7
0313:  MOVF   00,W
0314:  SUBLW  30
0315:  BTFSS  03.2
0316:  GOTO   32F
0317:  MOVLW  01
0318:  ADDWF  7B,W
0319:  MOVWF  04
031A:  BCF    03.7
031B:  BTFSC  7C.0
031C:  BSF    03.7
031D:  MOVF   00,W
031E:  SUBLW  78
031F:  BTFSC  03.2
0320:  GOTO   32B
0321:  MOVLW  01
0322:  ADDWF  7B,W
0323:  MOVWF  04
0324:  BCF    03.7
0325:  BTFSC  7C.0
0326:  BSF    03.7
0327:  MOVF   00,W
0328:  SUBLW  58
0329:  BTFSS  03.2
032A:  GOTO   32F
....................          sc+=2; 
032B:  MOVLW  02
032C:  ADDWF  7B,F
032D:  BTFSC  03.0
032E:  INCF   7C,F
....................       if(base==8 && *sc =='0') 
032F:  MOVF   75,W
0330:  SUBLW  08
0331:  BTFSS  03.2
0332:  GOTO   342
0333:  MOVF   7C,W
0334:  MOVWF  7A
0335:  MOVF   7B,W
0336:  MOVWF  04
0337:  BCF    03.7
0338:  BTFSC  7A.0
0339:  BSF    03.7
033A:  MOVF   00,W
033B:  SUBLW  30
033C:  BTFSS  03.2
033D:  GOTO   342
....................          sc+=1; 
033E:  MOVLW  01
033F:  ADDWF  7B,F
0340:  BTFSC  03.0
0341:  INCF   7C,F
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
0342:  MOVF   75,W
0343:  SUBLW  02
0344:  BTFSS  03.2
0345:  GOTO   35F
0346:  MOVF   7C,W
0347:  MOVWF  7A
0348:  MOVF   7B,W
0349:  MOVWF  04
034A:  BCF    03.7
034B:  BTFSC  7A.0
034C:  BSF    03.7
034D:  MOVF   00,W
034E:  SUBLW  30
034F:  BTFSS  03.2
0350:  GOTO   35F
0351:  MOVLW  01
0352:  ADDWF  7B,W
0353:  MOVWF  04
0354:  BCF    03.7
0355:  BTFSC  7C.0
0356:  BSF    03.7
0357:  MOVF   00,W
0358:  SUBLW  62
0359:  BTFSS  03.2
035A:  GOTO   35F
....................          sc+=2; 
035B:  MOVLW  02
035C:  ADDWF  7B,F
035D:  BTFSC  03.0
035E:  INCF   7C,F
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
035F:  GOTO   39B
0360:  MOVF   7C,W
0361:  MOVWF  7A
0362:  MOVF   7B,W
0363:  MOVWF  04
0364:  BCF    03.7
0365:  BTFSC  7A.0
0366:  BSF    03.7
0367:  MOVF   00,W
0368:  SUBLW  30
0369:  BTFSC  03.2
036A:  GOTO   36E
....................       base=10; 
036B:  MOVLW  0A
036C:  MOVWF  75
....................    else if (sc[1]=='x' || sc[1]=='X') 
036D:  GOTO   39B
036E:  MOVLW  01
036F:  ADDWF  7B,W
0370:  MOVWF  04
0371:  BCF    03.7
0372:  BTFSC  7C.0
0373:  BSF    03.7
0374:  MOVF   00,W
0375:  SUBLW  78
0376:  BTFSC  03.2
0377:  GOTO   382
0378:  MOVLW  01
0379:  ADDWF  7B,W
037A:  MOVWF  04
037B:  BCF    03.7
037C:  BTFSC  7C.0
037D:  BSF    03.7
037E:  MOVF   00,W
037F:  SUBLW  58
0380:  BTFSS  03.2
0381:  GOTO   389
....................       base =16,sc+=2; 
0382:  MOVLW  10
0383:  MOVWF  75
0384:  MOVLW  02
0385:  ADDWF  7B,F
0386:  BTFSC  03.0
0387:  INCF   7C,F
....................    else if(sc[1]=='b') 
0388:  GOTO   39B
0389:  MOVLW  01
038A:  ADDWF  7B,W
038B:  MOVWF  04
038C:  BCF    03.7
038D:  BTFSC  7C.0
038E:  BSF    03.7
038F:  MOVF   00,W
0390:  SUBLW  62
0391:  BTFSS  03.2
0392:  GOTO   399
....................       base=2,sc+=2; 
0393:  MOVLW  02
0394:  MOVWF  75
0395:  ADDWF  7B,F
0396:  BTFSC  03.0
0397:  INCF   7C,F
....................    else 
0398:  GOTO   39B
....................       base=8; 
0399:  MOVLW  08
039A:  MOVWF  75
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
039B:  MOVF   7C,W
039C:  MOVWF  7E
039D:  MOVF   7B,W
039E:  MOVWF  7D
039F:  MOVF   7C,W
03A0:  MOVWF  7A
03A1:  MOVF   7B,W
03A2:  MOVWF  04
03A3:  BCF    03.7
03A4:  BTFSC  7A.0
03A5:  BSF    03.7
03A6:  MOVF   00,W
03A7:  SUBLW  30
03A8:  BTFSS  03.2
03A9:  GOTO   3AE
03AA:  INCF   7B,F
03AB:  BTFSC  03.2
03AC:  INCF   7C,F
03AD:  GOTO   39F
....................    sd=memchr(digits,tolower(*sc),base); 
03AE:  MOVF   7C,W
03AF:  MOVWF  7A
03B0:  MOVF   7B,W
03B1:  MOVWF  04
03B2:  BCF    03.7
03B3:  BTFSC  7C.0
03B4:  BSF    03.7
03B5:  MOVF   00,W
03B6:  MOVWF  48
03B7:  SUBLW  40
03B8:  BTFSC  03.0
03B9:  GOTO   3C1
03BA:  MOVF   48,W
03BB:  SUBLW  5A
03BC:  BTFSS  03.0
03BD:  GOTO   3C1
03BE:  MOVF   48,W
03BF:  IORLW  20
03C0:  GOTO   3C2
03C1:  MOVF   48,W
03C2:  MOVWF  48
03C3:  CLRF   4B
03C4:  MOVLW  A4
03C5:  MOVWF  4A
03C6:  MOVF   48,W
03C7:  MOVWF  4C
03C8:  MOVF   75,W
03C9:  MOVWF  4D
03CA:  BCF    03.5
03CB:  CALL   24E
03CC:  MOVF   79,W
03CD:  BSF    03.5
03CE:  MOVWF  21
03CF:  MOVF   78,W
03D0:  MOVWF  20
....................    for(; sd!=0; ) 
03D1:  MOVF   20,F
03D2:  BTFSS  03.2
03D3:  GOTO   3D7
03D4:  MOVF   21,F
03D5:  BTFSC  03.2
03D6:  GOTO   453
....................    { 
....................       x=x*base+(int16)(sd-digits); 
03D7:  CLRF   7A
03D8:  MOVF   75,W
03D9:  MOVWF  77
03DA:  BTFSC  77.7
03DB:  DECF   7A,F
03DC:  MOVWF  48
03DD:  MOVF   7A,W
03DE:  MOVWF  49
03DF:  MOVF   23,W
03E0:  MOVWF  4C
03E1:  MOVF   22,W
03E2:  MOVWF  4B
03E3:  MOVF   49,W
03E4:  MOVWF  4E
03E5:  MOVF   48,W
03E6:  MOVWF  4D
*
0414:  MOVF   79,W
0415:  MOVWF  49
0416:  MOVF   78,W
0417:  MOVWF  48
0418:  MOVLW  A4
0419:  SUBWF  20,W
041A:  MOVWF  77
041B:  MOVF   21,W
041C:  MOVWF  7A
041D:  MOVLW  00
041E:  BTFSS  03.0
041F:  MOVLW  01
0420:  SUBWF  7A,F
0421:  MOVF   77,W
0422:  ADDWF  48,W
0423:  MOVWF  78
0424:  MOVF   49,W
0425:  BTFSC  03.0
0426:  INCFSZ 49,W
0427:  ADDWF  7A,F
0428:  MOVF   78,W
0429:  MOVWF  22
042A:  MOVF   7A,W
042B:  MOVWF  23
....................       ++sc; 
042C:  INCF   7B,F
042D:  BTFSC  03.2
042E:  INCF   7C,F
....................       sd=memchr(digits,tolower(*sc),base); 
042F:  MOVF   7C,W
0430:  MOVWF  7A
0431:  MOVF   7B,W
0432:  MOVWF  04
0433:  BCF    03.7
0434:  BTFSC  7C.0
0435:  BSF    03.7
0436:  MOVF   00,W
0437:  MOVWF  48
0438:  SUBLW  40
0439:  BTFSC  03.0
043A:  GOTO   442
043B:  MOVF   48,W
043C:  SUBLW  5A
043D:  BTFSS  03.0
043E:  GOTO   442
043F:  MOVF   48,W
0440:  IORLW  20
0441:  GOTO   443
0442:  MOVF   48,W
0443:  MOVWF  48
0444:  CLRF   4B
0445:  MOVLW  A4
0446:  MOVWF  4A
0447:  MOVF   48,W
0448:  MOVWF  4C
0449:  MOVF   75,W
044A:  MOVWF  4D
044B:  BCF    03.5
044C:  CALL   24E
044D:  MOVF   79,W
044E:  BSF    03.5
044F:  MOVWF  21
0450:  MOVF   78,W
0451:  MOVWF  20
....................    } 
0452:  GOTO   3D1
....................    if(s1==sc) 
0453:  MOVF   7B,W
0454:  SUBWF  7D,W
0455:  BTFSS  03.2
0456:  GOTO   46E
0457:  MOVF   7C,W
0458:  SUBWF  7E,W
0459:  BTFSS  03.2
045A:  GOTO   46E
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
045B:  MOVF   73,W
045C:  IORWF  74,W
045D:  BTFSC  03.2
045E:  GOTO   46A
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
045F:  MOVF   73,W
0460:  MOVWF  04
0461:  BCF    03.7
0462:  BTFSC  74.0
0463:  BSF    03.7
0464:  INCF   04,F
0465:  MOVF   72,W
0466:  MOVWF  00
0467:  DECF   04,F
0468:  MOVF   71,W
0469:  MOVWF  00
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
046A:  MOVLW  00
046B:  MOVWF  78
046C:  MOVWF  79
046D:  GOTO   481
....................    } 
....................    if (endptr) 
046E:  MOVF   73,W
046F:  IORWF  74,W
0470:  BTFSC  03.2
0471:  GOTO   47D
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
0472:  MOVF   73,W
0473:  MOVWF  04
0474:  BCF    03.7
0475:  BTFSC  74.0
0476:  BSF    03.7
0477:  INCF   04,F
0478:  MOVF   7C,W
0479:  MOVWF  00
047A:  DECF   04,F
047B:  MOVF   7B,W
047C:  MOVWF  00
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
047D:  MOVF   22,W
047E:  MOVWF  78
047F:  MOVF   23,W
0480:  MOVWF  79
.................... } 
0481:  BCF    03.5
0482:  RETURN
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #define use_portb_kbd TRUE 
.................... #include <kbd.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                             KBDD.C                                //// 
.................... ////                  Generic keypad scan driver                       //// 
.................... ////                                                                   //// 
.................... ////  kbd_init()   Must be called before any other function.           //// 
.................... ////                                                                   //// 
.................... ////  c = kbd_getc(c)  Will return a key value if pressed or /0 if not //// 
.................... ////                   This function should be called frequently so as //// 
.................... ////                   not to miss a key press.                        //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... ////////////////// The following defines the keypad layout on port D 
....................  
.................... // Un-comment the following define to use port B 
.................... // #define use_portb_kbd TRUE 
....................  
.................... // Make sure the port used has pull-up resistors (or the LCD) on 
.................... // the column pins 
....................  
....................  
.................... #if defined(__PCH__) 
.................... #if defined use_portb_kbd 
....................    #byte kbd = 0xF81                   // This puts the entire structure 
.................... #else 
....................    #byte kbd = 0xF83                   // This puts the entire structure 
.................... #endif 
.................... #else 
.................... #if defined use_portb_kbd 
....................    #byte kbd = 6                  // on to port B (at address 6) 
.................... #else 
....................    #byte kbd = 8                 // on to port D (at address 8) 
.................... #endif 
.................... #endif 
....................  
.................... #if defined use_portb_kbd 
....................    #define set_tris_kbd(x) set_tris_b(x) 
.................... #else 
....................    #define set_tris_kbd(x) set_tris_d(x) 
.................... #endif 
....................  
....................  
....................  
.................... //Keypad connection:   (for example column 0 is B2) 
.................... //                Bx: 
....................  
.................... #ifdef blue_keypad  ///////////////////////////////////// For the blue keypad 
.................... #define COL0 (1 << 2) 
.................... #define COL1 (1 << 3) 
.................... #define COL2 (1 << 6) 
....................  
.................... #define ROW0 (1 << 4) 
.................... #define ROW1 (1 << 7) 
.................... #define ROW2 (1 << 1) 
.................... #define ROW3 (1 << 5) 
....................  
.................... #else ////////////////////////////////////////////////// For the black keypad 
.................... #define COL0 (1 << 5) 
.................... #define COL1 (1 << 6) 
.................... #define COL2 (1 << 7) 
....................  
.................... #define ROW0 (1 << 1) 
.................... #define ROW1 (1 << 2) 
.................... #define ROW2 (1 << 3) 
.................... #define ROW3 (1 << 4) 
....................  
.................... #endif 
....................  
.................... #define ALL_ROWS (ROW0|ROW1|ROW2|ROW3) 
.................... #define ALL_PINS (ALL_ROWS|COL0|COL1|COL2) 
....................  
.................... // Keypad layout: 
.................... char const KEYS[4][3] = {{'1','2','3'}, 
....................                          {'4','5','6'}, 
....................                          {'7','8','9'}, 
....................                          {'*','0','#'}}; 
....................  
.................... #define KBD_DEBOUNCE_FACTOR 33    // Set this number to apx n/333 where 
....................                                   // n is the number of times you expect 
....................                                   // to call kbd_getc each second 
....................  
....................  
.................... void kbd_init() { 
.................... } 
*
013F:  BSF    0A.3
0140:  BCF    0A.4
0141:  GOTO   265 (RETURN)
....................  
.................... char kbd_getc( ) { 
....................    static BYTE kbd_call_count; 
*
0A5A:  CLRF   26
....................    static int1 kbd_down; 
0A5B:  BCF    27.0
....................    static char last_key; 
0A5C:  CLRF   28
....................    static BYTE col; 
0A5D:  CLRF   29
....................  
....................    BYTE kchar; 
....................    BYTE row; 
....................  
....................    kchar='\0'; 
*
01C5:  CLRF   71
....................    if(++kbd_call_count>KBD_DEBOUNCE_FACTOR) { 
01C6:  INCF   26,F
01C7:  MOVF   26,W
01C8:  SUBLW  21
01C9:  BTFSC  03.0
01CA:  GOTO   247
....................        switch (col) { 
01CB:  MOVF   29,W
01CC:  BTFSC  03.2
01CD:  GOTO   1D5
01CE:  XORLW  01
01CF:  BTFSC  03.2
01D0:  GOTO   1DB
01D1:  XORLW  03
01D2:  BTFSC  03.2
01D3:  GOTO   1E1
01D4:  GOTO   1E7
....................          case 0   : set_tris_kbd(ALL_PINS&~COL0); 
01D5:  MOVLW  DE
01D6:  BSF    03.5
01D7:  MOVWF  06
....................                     kbd=~COL0&ALL_PINS; 
01D8:  BCF    03.5
01D9:  MOVWF  06
....................                     break; 
01DA:  GOTO   1E7
....................          case 1   : set_tris_kbd(ALL_PINS&~COL1); 
01DB:  MOVLW  BE
01DC:  BSF    03.5
01DD:  MOVWF  06
....................                     kbd=~COL1&ALL_PINS; 
01DE:  BCF    03.5
01DF:  MOVWF  06
....................                     break; 
01E0:  GOTO   1E7
....................          case 2   : set_tris_kbd(ALL_PINS&~COL2); 
01E1:  MOVLW  7E
01E2:  BSF    03.5
01E3:  MOVWF  06
....................                     kbd=~COL2&ALL_PINS; 
01E4:  BCF    03.5
01E5:  MOVWF  06
....................                     break; 
01E6:  GOTO   1E7
....................        } 
....................  
....................        if(kbd_down) { 
01E7:  BTFSS  27.0
01E8:  GOTO   1F3
....................          if((kbd & (ALL_ROWS))==(ALL_ROWS)) { 
01E9:  MOVF   06,W
01EA:  ANDLW  1E
01EB:  SUBLW  1E
01EC:  BTFSS  03.2
01ED:  GOTO   1F2
....................            kbd_down=FALSE; 
01EE:  BCF    27.0
....................            kchar=last_key; 
01EF:  MOVF   28,W
01F0:  MOVWF  71
....................            last_key='\0'; 
01F1:  CLRF   28
....................          } 
....................        } else { 
01F2:  GOTO   246
....................           if((kbd & (ALL_ROWS))!=(ALL_ROWS)) { 
01F3:  MOVF   06,W
01F4:  ANDLW  1E
01F5:  SUBLW  1E
01F6:  BTFSC  03.2
01F7:  GOTO   241
....................              if((kbd & ROW0)==0) 
01F8:  MOVF   06,W
01F9:  ANDLW  02
01FA:  BTFSS  03.2
01FB:  GOTO   1FE
....................                row=0; 
01FC:  CLRF   72
....................              else if((kbd & ROW1)==0) 
01FD:  GOTO   212
01FE:  MOVF   06,W
01FF:  ANDLW  04
0200:  BTFSS  03.2
0201:  GOTO   205
....................                row=1; 
0202:  MOVLW  01
0203:  MOVWF  72
....................              else if((kbd & ROW2)==0) 
0204:  GOTO   212
0205:  MOVF   06,W
0206:  ANDLW  08
0207:  BTFSS  03.2
0208:  GOTO   20C
....................                row=2; 
0209:  MOVLW  02
020A:  MOVWF  72
....................              else if((kbd & ROW3)==0) 
020B:  GOTO   212
020C:  MOVF   06,W
020D:  ANDLW  10
020E:  BTFSS  03.2
020F:  GOTO   212
....................                row=3; 
0210:  MOVLW  03
0211:  MOVWF  72
....................              last_key =KEYS[row][col]; 
0212:  MOVF   72,W
0213:  MOVWF  73
0214:  MOVLW  03
0215:  MOVWF  74
*
023A:  MOVF   29,W
023B:  ADDWF  78,W
023C:  CALL   00C
023D:  MOVWF  78
023E:  MOVWF  28
....................              kbd_down = TRUE; 
023F:  BSF    27.0
....................           } else { 
0240:  GOTO   246
....................              ++col; 
0241:  INCF   29,F
....................              if(col==3) 
0242:  MOVF   29,W
0243:  SUBLW  03
0244:  BTFSC  03.2
....................                col=0; 
0245:  CLRF   29
....................           } 
....................        } 
....................       kbd_call_count=0; 
0246:  CLRF   26
....................    } 
....................   set_tris_kbd(ALL_PINS); 
0247:  MOVLW  FE
0248:  BSF    03.5
0249:  MOVWF  06
....................   return(kchar); 
024A:  MOVF   71,W
024B:  MOVWF  78
.................... } 
024C:  BCF    03.5
024D:  RETURN
....................  
....................  
.................... void main() { 
*
0A4C:  CLRF   04
0A4D:  BCF    03.7
0A4E:  MOVLW  1F
0A4F:  ANDWF  03,F
0A50:  BSF    03.5
0A51:  BSF    1F.0
0A52:  BSF    1F.1
0A53:  BSF    1F.2
0A54:  BCF    1F.3
0A55:  MOVLW  07
0A56:  MOVWF  1C
*
0A5E:  CLRF   61
0A5F:  CLRF   62
....................  
.................... char k; 
.................... char num2[20],num[20],rep[10];   //Stores the strings of the value 
.................... char *ptr,ptr2;  // pointer to convert the string 
.................... int c,z=0;   //index of the array 
.................... char value3=0;; 
.................... float b; 
.................... int16   value; 
.................... float value2; 
.................... float d; 
.................... lcd_init(); 
0A60:  BCF    0A.3
0A61:  GOTO   105
0A62:  BSF    0A.3
.................... kbd_init(); 
0A63:  BCF    0A.3
0A64:  GOTO   13F
0A65:  BSF    0A.3
.................... port_b_pullups(TRUE);  //Activate the internbal resistors 
0A66:  BSF    03.5
0A67:  BCF    01.7
.................... k=0; 
0A68:  BCF    03.5
0A69:  CLRF   2A
.................... d =0; 
0A6A:  CLRF   70
0A6B:  CLRF   6F
0A6C:  CLRF   6E
0A6D:  CLRF   6D
.................... while(z!=1){ 
0A6E:  DECFSZ 61,W
0A6F:  GOTO   271
0A70:  GOTO   75A
.................... value3=0;c=0; 
0A71:  CLRF   62
0A72:  CLRF   60
.................... lcd_gotoxy(1,1); 
0A73:  MOVLW  01
0A74:  BSF    03.5
0A75:  MOVWF  29
0A76:  MOVWF  2A
0A77:  BCF    0A.3
0A78:  BCF    03.5
0A79:  CALL   142
0A7A:  BSF    0A.3
.................... lcd_putc("Menu user:"); 
0A7B:  MOVLW  1C
0A7C:  BSF    03.6
0A7D:  MOVWF  0D
0A7E:  MOVLW  00
0A7F:  MOVWF  0F
0A80:  BCF    0A.3
0A81:  BCF    03.6
0A82:  CALL   187
0A83:  BSF    0A.3
.................... lcd_gotoxy(1,2); 
0A84:  MOVLW  01
0A85:  BSF    03.5
0A86:  MOVWF  29
0A87:  MOVLW  02
0A88:  MOVWF  2A
0A89:  BCF    0A.3
0A8A:  BCF    03.5
0A8B:  CALL   142
0A8C:  BSF    0A.3
.................... lcd_putc("+=1;-=2;*=3;/=4;"); 
0A8D:  MOVLW  22
0A8E:  BSF    03.6
0A8F:  MOVWF  0D
0A90:  MOVLW  00
0A91:  MOVWF  0F
0A92:  BCF    0A.3
0A93:  BCF    03.6
0A94:  CALL   187
0A95:  BSF    0A.3
.................... delay_ms(2000); 
0A96:  MOVLW  08
0A97:  MOVWF  71
0A98:  MOVLW  FA
0A99:  BSF    03.5
0A9A:  MOVWF  29
0A9B:  BCF    0A.3
0A9C:  BCF    03.5
0A9D:  CALL   08C
0A9E:  BSF    0A.3
0A9F:  DECFSZ 71,F
0AA0:  GOTO   298
.................... lcd_putc("\fchoice: "); 
0AA1:  MOVLW  2B
0AA2:  BSF    03.6
0AA3:  MOVWF  0D
0AA4:  MOVLW  00
0AA5:  MOVWF  0F
0AA6:  BCF    0A.3
0AA7:  BCF    03.6
0AA8:  CALL   187
0AA9:  BSF    0A.3
.................... while(c!=1){ 
0AAA:  DECFSZ 60,W
0AAB:  GOTO   2AD
0AAC:  GOTO   2B8
.................... value3=kbd_getc(); 
0AAD:  BCF    0A.3
0AAE:  CALL   1C5
0AAF:  BSF    0A.3
0AB0:  MOVF   78,W
0AB1:  MOVWF  62
.................... if (value3 != 0){ 
0AB2:  MOVF   62,F
0AB3:  BTFSC  03.2
0AB4:  GOTO   2B7
....................    c=1; 
0AB5:  MOVLW  01
0AB6:  MOVWF  60
....................  
.................... } 
.................... } 
0AB7:  GOTO   2AA
.................... lcd_putc("\f"); 
0AB8:  MOVLW  30
0AB9:  BSF    03.6
0ABA:  MOVWF  0D
0ABB:  MOVLW  00
0ABC:  MOVWF  0F
0ABD:  BCF    0A.3
0ABE:  BCF    03.6
0ABF:  CALL   187
0AC0:  BSF    0A.3
.................... switch(value3) 
.................... { 
0AC1:  MOVF   62,W
0AC2:  XORLW  31
0AC3:  BTFSC  03.2
0AC4:  GOTO   2CF
0AC5:  XORLW  03
0AC6:  BTFSC  03.2
0AC7:  GOTO   3D3
0AC8:  XORLW  01
0AC9:  BTFSC  03.2
0ACA:  GOTO   4D7
0ACB:  XORLW  07
0ACC:  BTFSC  03.2
0ACD:  GOTO   5DA
0ACE:  GOTO   6DD
.................... case '1': 
.................... { 
.................... lcd_putc("Suma: "); 
0ACF:  MOVLW  31
0AD0:  BSF    03.6
0AD1:  MOVWF  0D
0AD2:  MOVLW  00
0AD3:  MOVWF  0F
0AD4:  BCF    0A.3
0AD5:  BCF    03.6
0AD6:  CALL   187
0AD7:  BSF    0A.3
.................... c=0; 
0AD8:  CLRF   60
.................... while(k!='#') 
....................    { 
0AD9:  MOVF   2A,W
0ADA:  SUBLW  23
0ADB:  BTFSC  03.2
0ADC:  GOTO   30F
....................       k=kbd_getc(); 
0ADD:  BCF    0A.3
0ADE:  CALL   1C5
0ADF:  BSF    0A.3
0AE0:  MOVF   78,W
0AE1:  MOVWF  2A
....................       if(k!=0) 
0AE2:  MOVF   2A,F
0AE3:  BTFSC  03.2
0AE4:  GOTO   30E
....................          { 
....................          if(k=='*') 
0AE5:  MOVF   2A,W
0AE6:  SUBLW  2A
0AE7:  BTFSS  03.2
0AE8:  GOTO   2F9
....................          { 
....................          k='.'; 
0AE9:  MOVLW  2E
0AEA:  MOVWF  2A
....................          num[c]=k; 
0AEB:  MOVLW  3F
0AEC:  ADDWF  60,W
0AED:  MOVWF  04
0AEE:  BCF    03.7
0AEF:  MOVF   2A,W
0AF0:  MOVWF  00
....................          c++; 
0AF1:  INCF   60,F
....................          printf(lcd_putc, "%c",k); 
0AF2:  MOVF   2A,W
0AF3:  BSF    03.5
0AF4:  MOVWF  28
0AF5:  BCF    0A.3
0AF6:  BCF    03.5
0AF7:  CALL   156
0AF8:  BSF    0A.3
....................          } 
....................           if(k!='#'){  
0AF9:  MOVF   2A,W
0AFA:  SUBLW  23
0AFB:  BTFSC  03.2
0AFC:  GOTO   30C
....................            num[c]=k; 
0AFD:  MOVLW  3F
0AFE:  ADDWF  60,W
0AFF:  MOVWF  04
0B00:  BCF    03.7
0B01:  MOVF   2A,W
0B02:  MOVWF  00
....................             c++; 
0B03:  INCF   60,F
....................             printf(lcd_putc, "%c",k); 
0B04:  MOVF   2A,W
0B05:  BSF    03.5
0B06:  MOVWF  28
0B07:  BCF    0A.3
0B08:  BCF    03.5
0B09:  CALL   156
0B0A:  BSF    0A.3
....................            } 
....................            else k = '#'; 
0B0B:  GOTO   30E
0B0C:  MOVLW  23
0B0D:  MOVWF  2A
....................          } 
....................    } 
0B0E:  GOTO   2D9
....................    k=0; 
0B0F:  CLRF   2A
....................    c=0; 
0B10:  CLRF   60
....................    //lcd_putc("\f"); 
....................    lcd_putc(" + "); 
0B11:  MOVLW  35
0B12:  BSF    03.6
0B13:  MOVWF  0D
0B14:  MOVLW  00
0B15:  MOVWF  0F
0B16:  BCF    0A.3
0B17:  BCF    03.6
0B18:  CALL   187
0B19:  BSF    0A.3
.................... while(k!='#') 
....................    { 
0B1A:  MOVF   2A,W
0B1B:  SUBLW  23
0B1C:  BTFSC  03.2
0B1D:  GOTO   350
....................       k=kbd_getc(); 
0B1E:  BCF    0A.3
0B1F:  CALL   1C5
0B20:  BSF    0A.3
0B21:  MOVF   78,W
0B22:  MOVWF  2A
....................       if(k!=0) 
0B23:  MOVF   2A,F
0B24:  BTFSC  03.2
0B25:  GOTO   34F
....................          { 
....................          if(k=='*') 
0B26:  MOVF   2A,W
0B27:  SUBLW  2A
0B28:  BTFSS  03.2
0B29:  GOTO   33A
....................          { 
....................          k='.'; 
0B2A:  MOVLW  2E
0B2B:  MOVWF  2A
....................          rep[c]=k; 
0B2C:  MOVLW  53
0B2D:  ADDWF  60,W
0B2E:  MOVWF  04
0B2F:  BCF    03.7
0B30:  MOVF   2A,W
0B31:  MOVWF  00
....................          c++; 
0B32:  INCF   60,F
....................          printf(lcd_putc, "%c",k); 
0B33:  MOVF   2A,W
0B34:  BSF    03.5
0B35:  MOVWF  28
0B36:  BCF    0A.3
0B37:  BCF    03.5
0B38:  CALL   156
0B39:  BSF    0A.3
....................          } 
....................            if(k!='#'){  
0B3A:  MOVF   2A,W
0B3B:  SUBLW  23
0B3C:  BTFSC  03.2
0B3D:  GOTO   34D
....................            rep[c]=k; 
0B3E:  MOVLW  53
0B3F:  ADDWF  60,W
0B40:  MOVWF  04
0B41:  BCF    03.7
0B42:  MOVF   2A,W
0B43:  MOVWF  00
....................             c++; 
0B44:  INCF   60,F
....................             printf(lcd_putc, "%c",k); 
0B45:  MOVF   2A,W
0B46:  BSF    03.5
0B47:  MOVWF  28
0B48:  BCF    0A.3
0B49:  BCF    03.5
0B4A:  CALL   156
0B4B:  BSF    0A.3
....................            } 
....................            else k = '#'; 
0B4C:  GOTO   34F
0B4D:  MOVLW  23
0B4E:  MOVWF  2A
....................          } 
....................    } 
0B4F:  GOTO   31A
....................    lcd_putc("\f"); 
0B50:  MOVLW  37
0B51:  BSF    03.6
0B52:  MOVWF  0D
0B53:  MOVLW  00
0B54:  MOVWF  0F
0B55:  BCF    0A.3
0B56:  BCF    03.6
0B57:  CALL   187
0B58:  BSF    0A.3
....................    value=strtoul(num,&ptr,10); 
0B59:  CLRF   72
0B5A:  MOVLW  3F
0B5B:  MOVWF  71
0B5C:  CLRF   74
0B5D:  MOVLW  5D
0B5E:  MOVWF  73
0B5F:  MOVLW  0A
0B60:  MOVWF  75
0B61:  BCF    0A.3
0B62:  CALL   273
0B63:  BSF    0A.3
0B64:  MOVF   79,W
0B65:  MOVWF  68
0B66:  MOVF   78,W
0B67:  MOVWF  67
....................    value2 =strtod(rep,&ptr2); 
0B68:  CLRF   72
0B69:  MOVLW  53
0B6A:  MOVWF  71
0B6B:  CLRF   74
0B6C:  MOVLW  5F
0B6D:  MOVWF  73
0B6E:  CALL   000
0B6F:  MOVF   7A,W
0B70:  MOVWF  6C
0B71:  MOVF   79,W
0B72:  MOVWF  6B
0B73:  MOVF   78,W
0B74:  MOVWF  6A
0B75:  MOVF   77,W
0B76:  MOVWF  69
....................    d = value + value2; 
0B77:  MOVF   68,W
0B78:  BSF    03.5
0B79:  MOVWF  2C
0B7A:  BCF    03.5
0B7B:  MOVF   67,W
0B7C:  BSF    03.5
0B7D:  MOVWF  2B
0B7E:  BCF    0A.3
0B7F:  BCF    03.5
0B80:  CALL   4FA
0B81:  BSF    0A.3
0B82:  BCF    03.1
0B83:  MOVF   7A,W
0B84:  BSF    03.5
0B85:  MOVWF  2E
0B86:  MOVF   79,W
0B87:  MOVWF  2D
0B88:  MOVF   78,W
0B89:  MOVWF  2C
0B8A:  MOVF   77,W
0B8B:  MOVWF  2B
0B8C:  BCF    03.5
0B8D:  MOVF   6C,W
0B8E:  BSF    03.5
0B8F:  MOVWF  32
0B90:  BCF    03.5
0B91:  MOVF   6B,W
0B92:  BSF    03.5
0B93:  MOVWF  31
0B94:  BCF    03.5
0B95:  MOVF   6A,W
0B96:  BSF    03.5
0B97:  MOVWF  30
0B98:  BCF    03.5
0B99:  MOVF   69,W
0B9A:  BSF    03.5
0B9B:  MOVWF  2F
0B9C:  BCF    0A.3
0B9D:  BCF    03.5
0B9E:  CALL   5E5
0B9F:  BSF    0A.3
0BA0:  MOVF   7A,W
0BA1:  MOVWF  70
0BA2:  MOVF   79,W
0BA3:  MOVWF  6F
0BA4:  MOVF   78,W
0BA5:  MOVWF  6E
0BA6:  MOVF   77,W
0BA7:  MOVWF  6D
....................    lcd_putc("La suma es: "); 
0BA8:  MOVLW  38
0BA9:  BSF    03.6
0BAA:  MOVWF  0D
0BAB:  MOVLW  00
0BAC:  MOVWF  0F
0BAD:  BCF    0A.3
0BAE:  BCF    03.6
0BAF:  CALL   187
0BB0:  BSF    0A.3
....................    lcd_gotoxy(1,2); 
0BB1:  MOVLW  01
0BB2:  BSF    03.5
0BB3:  MOVWF  29
0BB4:  MOVLW  02
0BB5:  MOVWF  2A
0BB6:  BCF    0A.3
0BB7:  BCF    03.5
0BB8:  CALL   142
0BB9:  BSF    0A.3
....................    printf(lcd_putc, "%f",d); 
0BBA:  MOVLW  89
0BBB:  MOVWF  04
0BBC:  MOVF   70,W
0BBD:  MOVWF  74
0BBE:  MOVF   6F,W
0BBF:  MOVWF  73
0BC0:  MOVF   6E,W
0BC1:  MOVWF  72
0BC2:  MOVF   6D,W
0BC3:  MOVWF  71
0BC4:  MOVLW  02
0BC5:  MOVWF  75
0BC6:  CALL   143
....................    delay_ms(2000); 
0BC7:  MOVLW  08
0BC8:  MOVWF  71
0BC9:  MOVLW  FA
0BCA:  BSF    03.5
0BCB:  MOVWF  29
0BCC:  BCF    0A.3
0BCD:  BCF    03.5
0BCE:  CALL   08C
0BCF:  BSF    0A.3
0BD0:  DECFSZ 71,F
0BD1:  GOTO   3C9
....................    
....................    
....................    
....................    
....................  break; 
0BD2:  GOTO   6DE
.................... } 
.................... case '2': 
.................... { 
.................... lcd_putc("Resta: "); 
0BD3:  MOVLW  3F
0BD4:  BSF    03.6
0BD5:  MOVWF  0D
0BD6:  MOVLW  00
0BD7:  MOVWF  0F
0BD8:  BCF    0A.3
0BD9:  BCF    03.6
0BDA:  CALL   187
0BDB:  BSF    0A.3
.................... c=0; 
0BDC:  CLRF   60
.................... while(k!='#') 
....................    { 
0BDD:  MOVF   2A,W
0BDE:  SUBLW  23
0BDF:  BTFSC  03.2
0BE0:  GOTO   413
....................       k=kbd_getc(); 
0BE1:  BCF    0A.3
0BE2:  CALL   1C5
0BE3:  BSF    0A.3
0BE4:  MOVF   78,W
0BE5:  MOVWF  2A
....................       if(k!=0) 
0BE6:  MOVF   2A,F
0BE7:  BTFSC  03.2
0BE8:  GOTO   412
....................          { 
....................          if(k=='*') 
0BE9:  MOVF   2A,W
0BEA:  SUBLW  2A
0BEB:  BTFSS  03.2
0BEC:  GOTO   3FD
....................          { 
....................          k='.'; 
0BED:  MOVLW  2E
0BEE:  MOVWF  2A
....................          num[c]=k; 
0BEF:  MOVLW  3F
0BF0:  ADDWF  60,W
0BF1:  MOVWF  04
0BF2:  BCF    03.7
0BF3:  MOVF   2A,W
0BF4:  MOVWF  00
....................          c++; 
0BF5:  INCF   60,F
....................          printf(lcd_putc, "%c",k); 
0BF6:  MOVF   2A,W
0BF7:  BSF    03.5
0BF8:  MOVWF  28
0BF9:  BCF    0A.3
0BFA:  BCF    03.5
0BFB:  CALL   156
0BFC:  BSF    0A.3
....................          } 
....................           if(k!='#'){  
0BFD:  MOVF   2A,W
0BFE:  SUBLW  23
0BFF:  BTFSC  03.2
0C00:  GOTO   410
....................            num[c]=k; 
0C01:  MOVLW  3F
0C02:  ADDWF  60,W
0C03:  MOVWF  04
0C04:  BCF    03.7
0C05:  MOVF   2A,W
0C06:  MOVWF  00
....................             c++; 
0C07:  INCF   60,F
....................             printf(lcd_putc, "%c",k); 
0C08:  MOVF   2A,W
0C09:  BSF    03.5
0C0A:  MOVWF  28
0C0B:  BCF    0A.3
0C0C:  BCF    03.5
0C0D:  CALL   156
0C0E:  BSF    0A.3
....................            } 
....................            else k = '#'; 
0C0F:  GOTO   412
0C10:  MOVLW  23
0C11:  MOVWF  2A
....................          } 
....................    } 
0C12:  GOTO   3DD
....................    k=0; 
0C13:  CLRF   2A
....................    c=0; 
0C14:  CLRF   60
....................    //lcd_putc("\f"); 
....................    lcd_putc(" - "); 
0C15:  MOVLW  43
0C16:  BSF    03.6
0C17:  MOVWF  0D
0C18:  MOVLW  00
0C19:  MOVWF  0F
0C1A:  BCF    0A.3
0C1B:  BCF    03.6
0C1C:  CALL   187
0C1D:  BSF    0A.3
.................... while(k!='#') 
....................    { 
0C1E:  MOVF   2A,W
0C1F:  SUBLW  23
0C20:  BTFSC  03.2
0C21:  GOTO   454
....................       k=kbd_getc(); 
0C22:  BCF    0A.3
0C23:  CALL   1C5
0C24:  BSF    0A.3
0C25:  MOVF   78,W
0C26:  MOVWF  2A
....................       if(k!=0) 
0C27:  MOVF   2A,F
0C28:  BTFSC  03.2
0C29:  GOTO   453
....................          { 
....................          if(k=='*') 
0C2A:  MOVF   2A,W
0C2B:  SUBLW  2A
0C2C:  BTFSS  03.2
0C2D:  GOTO   43E
....................          { 
....................          k='.'; 
0C2E:  MOVLW  2E
0C2F:  MOVWF  2A
....................          rep[c]=k; 
0C30:  MOVLW  53
0C31:  ADDWF  60,W
0C32:  MOVWF  04
0C33:  BCF    03.7
0C34:  MOVF   2A,W
0C35:  MOVWF  00
....................          c++; 
0C36:  INCF   60,F
....................          printf(lcd_putc, "%c",k); 
0C37:  MOVF   2A,W
0C38:  BSF    03.5
0C39:  MOVWF  28
0C3A:  BCF    0A.3
0C3B:  BCF    03.5
0C3C:  CALL   156
0C3D:  BSF    0A.3
....................          } 
....................            if(k!='#'){  
0C3E:  MOVF   2A,W
0C3F:  SUBLW  23
0C40:  BTFSC  03.2
0C41:  GOTO   451
....................            rep[c]=k; 
0C42:  MOVLW  53
0C43:  ADDWF  60,W
0C44:  MOVWF  04
0C45:  BCF    03.7
0C46:  MOVF   2A,W
0C47:  MOVWF  00
....................             c++; 
0C48:  INCF   60,F
....................             printf(lcd_putc, "%c",k); 
0C49:  MOVF   2A,W
0C4A:  BSF    03.5
0C4B:  MOVWF  28
0C4C:  BCF    0A.3
0C4D:  BCF    03.5
0C4E:  CALL   156
0C4F:  BSF    0A.3
....................            } 
....................            else k = '#'; 
0C50:  GOTO   453
0C51:  MOVLW  23
0C52:  MOVWF  2A
....................          } 
....................    } 
0C53:  GOTO   41E
....................    lcd_putc("\f"); 
0C54:  MOVLW  45
0C55:  BSF    03.6
0C56:  MOVWF  0D
0C57:  MOVLW  00
0C58:  MOVWF  0F
0C59:  BCF    0A.3
0C5A:  BCF    03.6
0C5B:  CALL   187
0C5C:  BSF    0A.3
....................    value=strtoul(num,&ptr,10); 
0C5D:  CLRF   72
0C5E:  MOVLW  3F
0C5F:  MOVWF  71
0C60:  CLRF   74
0C61:  MOVLW  5D
0C62:  MOVWF  73
0C63:  MOVLW  0A
0C64:  MOVWF  75
0C65:  BCF    0A.3
0C66:  CALL   273
0C67:  BSF    0A.3
0C68:  MOVF   79,W
0C69:  MOVWF  68
0C6A:  MOVF   78,W
0C6B:  MOVWF  67
....................    value2 =strtod(rep,&ptr2); 
0C6C:  CLRF   72
0C6D:  MOVLW  53
0C6E:  MOVWF  71
0C6F:  CLRF   74
0C70:  MOVLW  5F
0C71:  MOVWF  73
0C72:  CALL   000
0C73:  MOVF   7A,W
0C74:  MOVWF  6C
0C75:  MOVF   79,W
0C76:  MOVWF  6B
0C77:  MOVF   78,W
0C78:  MOVWF  6A
0C79:  MOVF   77,W
0C7A:  MOVWF  69
....................    d = value - value2; 
0C7B:  MOVF   68,W
0C7C:  BSF    03.5
0C7D:  MOVWF  2C
0C7E:  BCF    03.5
0C7F:  MOVF   67,W
0C80:  BSF    03.5
0C81:  MOVWF  2B
0C82:  BCF    0A.3
0C83:  BCF    03.5
0C84:  CALL   4FA
0C85:  BSF    0A.3
0C86:  BSF    03.1
0C87:  MOVF   7A,W
0C88:  BSF    03.5
0C89:  MOVWF  2E
0C8A:  MOVF   79,W
0C8B:  MOVWF  2D
0C8C:  MOVF   78,W
0C8D:  MOVWF  2C
0C8E:  MOVF   77,W
0C8F:  MOVWF  2B
0C90:  BCF    03.5
0C91:  MOVF   6C,W
0C92:  BSF    03.5
0C93:  MOVWF  32
0C94:  BCF    03.5
0C95:  MOVF   6B,W
0C96:  BSF    03.5
0C97:  MOVWF  31
0C98:  BCF    03.5
0C99:  MOVF   6A,W
0C9A:  BSF    03.5
0C9B:  MOVWF  30
0C9C:  BCF    03.5
0C9D:  MOVF   69,W
0C9E:  BSF    03.5
0C9F:  MOVWF  2F
0CA0:  BCF    0A.3
0CA1:  BCF    03.5
0CA2:  CALL   5E5
0CA3:  BSF    0A.3
0CA4:  MOVF   7A,W
0CA5:  MOVWF  70
0CA6:  MOVF   79,W
0CA7:  MOVWF  6F
0CA8:  MOVF   78,W
0CA9:  MOVWF  6E
0CAA:  MOVF   77,W
0CAB:  MOVWF  6D
....................    lcd_putc("La resta es: "); 
0CAC:  MOVLW  46
0CAD:  BSF    03.6
0CAE:  MOVWF  0D
0CAF:  MOVLW  00
0CB0:  MOVWF  0F
0CB1:  BCF    0A.3
0CB2:  BCF    03.6
0CB3:  CALL   187
0CB4:  BSF    0A.3
....................    lcd_gotoxy(1,2); 
0CB5:  MOVLW  01
0CB6:  BSF    03.5
0CB7:  MOVWF  29
0CB8:  MOVLW  02
0CB9:  MOVWF  2A
0CBA:  BCF    0A.3
0CBB:  BCF    03.5
0CBC:  CALL   142
0CBD:  BSF    0A.3
....................    printf(lcd_putc, "%f",d); 
0CBE:  MOVLW  89
0CBF:  MOVWF  04
0CC0:  MOVF   70,W
0CC1:  MOVWF  74
0CC2:  MOVF   6F,W
0CC3:  MOVWF  73
0CC4:  MOVF   6E,W
0CC5:  MOVWF  72
0CC6:  MOVF   6D,W
0CC7:  MOVWF  71
0CC8:  MOVLW  02
0CC9:  MOVWF  75
0CCA:  CALL   143
....................    delay_ms(2000); 
0CCB:  MOVLW  08
0CCC:  MOVWF  71
0CCD:  MOVLW  FA
0CCE:  BSF    03.5
0CCF:  MOVWF  29
0CD0:  BCF    0A.3
0CD1:  BCF    03.5
0CD2:  CALL   08C
0CD3:  BSF    0A.3
0CD4:  DECFSZ 71,F
0CD5:  GOTO   4CD
....................    
....................    
....................    
....................    
....................  break; 
0CD6:  GOTO   6DE
.................... } 
.................... case '3': 
.................... { 
.................... lcd_putc("Multipli: "); 
0CD7:  MOVLW  4D
0CD8:  BSF    03.6
0CD9:  MOVWF  0D
0CDA:  MOVLW  00
0CDB:  MOVWF  0F
0CDC:  BCF    0A.3
0CDD:  BCF    03.6
0CDE:  CALL   187
0CDF:  BSF    0A.3
.................... c=0; 
0CE0:  CLRF   60
.................... while(k!='#') 
....................    { 
0CE1:  MOVF   2A,W
0CE2:  SUBLW  23
0CE3:  BTFSC  03.2
0CE4:  GOTO   517
....................       k=kbd_getc(); 
0CE5:  BCF    0A.3
0CE6:  CALL   1C5
0CE7:  BSF    0A.3
0CE8:  MOVF   78,W
0CE9:  MOVWF  2A
....................       if(k!=0) 
0CEA:  MOVF   2A,F
0CEB:  BTFSC  03.2
0CEC:  GOTO   516
....................          { 
....................          if(k=='*') 
0CED:  MOVF   2A,W
0CEE:  SUBLW  2A
0CEF:  BTFSS  03.2
0CF0:  GOTO   501
....................          { 
....................          k='.'; 
0CF1:  MOVLW  2E
0CF2:  MOVWF  2A
....................          num[c]=k; 
0CF3:  MOVLW  3F
0CF4:  ADDWF  60,W
0CF5:  MOVWF  04
0CF6:  BCF    03.7
0CF7:  MOVF   2A,W
0CF8:  MOVWF  00
....................          c++; 
0CF9:  INCF   60,F
....................          printf(lcd_putc, "%c",k); 
0CFA:  MOVF   2A,W
0CFB:  BSF    03.5
0CFC:  MOVWF  28
0CFD:  BCF    0A.3
0CFE:  BCF    03.5
0CFF:  CALL   156
0D00:  BSF    0A.3
....................          } 
....................           if(k!='#'){  
0D01:  MOVF   2A,W
0D02:  SUBLW  23
0D03:  BTFSC  03.2
0D04:  GOTO   514
....................            num[c]=k; 
0D05:  MOVLW  3F
0D06:  ADDWF  60,W
0D07:  MOVWF  04
0D08:  BCF    03.7
0D09:  MOVF   2A,W
0D0A:  MOVWF  00
....................             c++; 
0D0B:  INCF   60,F
....................             printf(lcd_putc, "%c",k); 
0D0C:  MOVF   2A,W
0D0D:  BSF    03.5
0D0E:  MOVWF  28
0D0F:  BCF    0A.3
0D10:  BCF    03.5
0D11:  CALL   156
0D12:  BSF    0A.3
....................            } 
....................            else k = '#'; 
0D13:  GOTO   516
0D14:  MOVLW  23
0D15:  MOVWF  2A
....................          } 
....................    } 
0D16:  GOTO   4E1
....................    k=0; 
0D17:  CLRF   2A
....................    c=0; 
0D18:  CLRF   60
....................    //lcd_putc("\f"); 
....................    lcd_putc(" * "); 
0D19:  MOVLW  53
0D1A:  BSF    03.6
0D1B:  MOVWF  0D
0D1C:  MOVLW  00
0D1D:  MOVWF  0F
0D1E:  BCF    0A.3
0D1F:  BCF    03.6
0D20:  CALL   187
0D21:  BSF    0A.3
.................... while(k!='#') 
....................    { 
0D22:  MOVF   2A,W
0D23:  SUBLW  23
0D24:  BTFSC  03.2
0D25:  GOTO   558
....................       k=kbd_getc(); 
0D26:  BCF    0A.3
0D27:  CALL   1C5
0D28:  BSF    0A.3
0D29:  MOVF   78,W
0D2A:  MOVWF  2A
....................       if(k!=0) 
0D2B:  MOVF   2A,F
0D2C:  BTFSC  03.2
0D2D:  GOTO   557
....................          { 
....................          if(k=='*') 
0D2E:  MOVF   2A,W
0D2F:  SUBLW  2A
0D30:  BTFSS  03.2
0D31:  GOTO   542
....................          { 
....................          k='.'; 
0D32:  MOVLW  2E
0D33:  MOVWF  2A
....................          rep[c]=k; 
0D34:  MOVLW  53
0D35:  ADDWF  60,W
0D36:  MOVWF  04
0D37:  BCF    03.7
0D38:  MOVF   2A,W
0D39:  MOVWF  00
....................          c++; 
0D3A:  INCF   60,F
....................          printf(lcd_putc, "%c",k); 
0D3B:  MOVF   2A,W
0D3C:  BSF    03.5
0D3D:  MOVWF  28
0D3E:  BCF    0A.3
0D3F:  BCF    03.5
0D40:  CALL   156
0D41:  BSF    0A.3
....................          } 
....................            if(k!='#'){  
0D42:  MOVF   2A,W
0D43:  SUBLW  23
0D44:  BTFSC  03.2
0D45:  GOTO   555
....................            rep[c]=k; 
0D46:  MOVLW  53
0D47:  ADDWF  60,W
0D48:  MOVWF  04
0D49:  BCF    03.7
0D4A:  MOVF   2A,W
0D4B:  MOVWF  00
....................             c++; 
0D4C:  INCF   60,F
....................             printf(lcd_putc, "%c",k); 
0D4D:  MOVF   2A,W
0D4E:  BSF    03.5
0D4F:  MOVWF  28
0D50:  BCF    0A.3
0D51:  BCF    03.5
0D52:  CALL   156
0D53:  BSF    0A.3
....................            } 
....................            else k = '#'; 
0D54:  GOTO   557
0D55:  MOVLW  23
0D56:  MOVWF  2A
....................          } 
....................    } 
0D57:  GOTO   522
....................    lcd_putc("\f"); 
0D58:  MOVLW  55
0D59:  BSF    03.6
0D5A:  MOVWF  0D
0D5B:  MOVLW  00
0D5C:  MOVWF  0F
0D5D:  BCF    0A.3
0D5E:  BCF    03.6
0D5F:  CALL   187
0D60:  BSF    0A.3
....................    value=strtoul(num,&ptr,10); 
0D61:  CLRF   72
0D62:  MOVLW  3F
0D63:  MOVWF  71
0D64:  CLRF   74
0D65:  MOVLW  5D
0D66:  MOVWF  73
0D67:  MOVLW  0A
0D68:  MOVWF  75
0D69:  BCF    0A.3
0D6A:  CALL   273
0D6B:  BSF    0A.3
0D6C:  MOVF   79,W
0D6D:  MOVWF  68
0D6E:  MOVF   78,W
0D6F:  MOVWF  67
....................    value2 =strtod(rep,&ptr2); 
0D70:  CLRF   72
0D71:  MOVLW  53
0D72:  MOVWF  71
0D73:  CLRF   74
0D74:  MOVLW  5F
0D75:  MOVWF  73
0D76:  CALL   000
0D77:  MOVF   7A,W
0D78:  MOVWF  6C
0D79:  MOVF   79,W
0D7A:  MOVWF  6B
0D7B:  MOVF   78,W
0D7C:  MOVWF  6A
0D7D:  MOVF   77,W
0D7E:  MOVWF  69
....................    d = value * value2; 
0D7F:  MOVF   68,W
0D80:  BSF    03.5
0D81:  MOVWF  2C
0D82:  BCF    03.5
0D83:  MOVF   67,W
0D84:  BSF    03.5
0D85:  MOVWF  2B
0D86:  BCF    0A.3
0D87:  BCF    03.5
0D88:  CALL   4FA
0D89:  BSF    0A.3
0D8A:  MOVF   7A,W
0D8B:  BSF    03.5
0D8C:  MOVWF  2B
0D8D:  MOVF   79,W
0D8E:  MOVWF  2A
0D8F:  MOVF   78,W
0D90:  MOVWF  29
0D91:  MOVF   77,W
0D92:  MOVWF  28
0D93:  BCF    03.5
0D94:  MOVF   6C,W
0D95:  BSF    03.5
0D96:  MOVWF  2F
0D97:  BCF    03.5
0D98:  MOVF   6B,W
0D99:  BSF    03.5
0D9A:  MOVWF  2E
0D9B:  BCF    03.5
0D9C:  MOVF   6A,W
0D9D:  BSF    03.5
0D9E:  MOVWF  2D
0D9F:  BCF    03.5
0DA0:  MOVF   69,W
0DA1:  BSF    03.5
0DA2:  MOVWF  2C
0DA3:  BCF    0A.3
0DA4:  BCF    03.5
0DA5:  CALL   483
0DA6:  BSF    0A.3
0DA7:  MOVF   7A,W
0DA8:  MOVWF  70
0DA9:  MOVF   79,W
0DAA:  MOVWF  6F
0DAB:  MOVF   78,W
0DAC:  MOVWF  6E
0DAD:  MOVF   77,W
0DAE:  MOVWF  6D
....................    lcd_putc("La multi is: "); 
0DAF:  MOVLW  56
0DB0:  BSF    03.6
0DB1:  MOVWF  0D
0DB2:  MOVLW  00
0DB3:  MOVWF  0F
0DB4:  BCF    0A.3
0DB5:  BCF    03.6
0DB6:  CALL   187
0DB7:  BSF    0A.3
....................    lcd_gotoxy(1,2); 
0DB8:  MOVLW  01
0DB9:  BSF    03.5
0DBA:  MOVWF  29
0DBB:  MOVLW  02
0DBC:  MOVWF  2A
0DBD:  BCF    0A.3
0DBE:  BCF    03.5
0DBF:  CALL   142
0DC0:  BSF    0A.3
....................    printf(lcd_putc, "%f",d); 
0DC1:  MOVLW  89
0DC2:  MOVWF  04
0DC3:  MOVF   70,W
0DC4:  MOVWF  74
0DC5:  MOVF   6F,W
0DC6:  MOVWF  73
0DC7:  MOVF   6E,W
0DC8:  MOVWF  72
0DC9:  MOVF   6D,W
0DCA:  MOVWF  71
0DCB:  MOVLW  02
0DCC:  MOVWF  75
0DCD:  CALL   143
....................    delay_ms(2000); 
0DCE:  MOVLW  08
0DCF:  MOVWF  71
0DD0:  MOVLW  FA
0DD1:  BSF    03.5
0DD2:  MOVWF  29
0DD3:  BCF    0A.3
0DD4:  BCF    03.5
0DD5:  CALL   08C
0DD6:  BSF    0A.3
0DD7:  DECFSZ 71,F
0DD8:  GOTO   5D0
....................    
....................    
....................    
....................    
....................  break; 
0DD9:  GOTO   6DE
.................... } 
.................... case '4': 
.................... { 
.................... lcd_putc("Division: "); 
0DDA:  MOVLW  5D
0DDB:  BSF    03.6
0DDC:  MOVWF  0D
0DDD:  MOVLW  00
0DDE:  MOVWF  0F
0DDF:  BCF    0A.3
0DE0:  BCF    03.6
0DE1:  CALL   187
0DE2:  BSF    0A.3
.................... c=0; 
0DE3:  CLRF   60
.................... while(k!='#') 
....................    { 
0DE4:  MOVF   2A,W
0DE5:  SUBLW  23
0DE6:  BTFSC  03.2
0DE7:  GOTO   61A
....................       k=kbd_getc(); 
0DE8:  BCF    0A.3
0DE9:  CALL   1C5
0DEA:  BSF    0A.3
0DEB:  MOVF   78,W
0DEC:  MOVWF  2A
....................       if(k!=0) 
0DED:  MOVF   2A,F
0DEE:  BTFSC  03.2
0DEF:  GOTO   619
....................          { 
....................          if(k=='*') 
0DF0:  MOVF   2A,W
0DF1:  SUBLW  2A
0DF2:  BTFSS  03.2
0DF3:  GOTO   604
....................          { 
....................          k='.'; 
0DF4:  MOVLW  2E
0DF5:  MOVWF  2A
....................          num[c]=k; 
0DF6:  MOVLW  3F
0DF7:  ADDWF  60,W
0DF8:  MOVWF  04
0DF9:  BCF    03.7
0DFA:  MOVF   2A,W
0DFB:  MOVWF  00
....................          c++; 
0DFC:  INCF   60,F
....................          printf(lcd_putc, "%c",k); 
0DFD:  MOVF   2A,W
0DFE:  BSF    03.5
0DFF:  MOVWF  28
0E00:  BCF    0A.3
0E01:  BCF    03.5
0E02:  CALL   156
0E03:  BSF    0A.3
....................          } 
....................           if(k!='#'){  
0E04:  MOVF   2A,W
0E05:  SUBLW  23
0E06:  BTFSC  03.2
0E07:  GOTO   617
....................            num[c]=k; 
0E08:  MOVLW  3F
0E09:  ADDWF  60,W
0E0A:  MOVWF  04
0E0B:  BCF    03.7
0E0C:  MOVF   2A,W
0E0D:  MOVWF  00
....................             c++; 
0E0E:  INCF   60,F
....................             printf(lcd_putc, "%c",k); 
0E0F:  MOVF   2A,W
0E10:  BSF    03.5
0E11:  MOVWF  28
0E12:  BCF    0A.3
0E13:  BCF    03.5
0E14:  CALL   156
0E15:  BSF    0A.3
....................            } 
....................            else k = '#'; 
0E16:  GOTO   619
0E17:  MOVLW  23
0E18:  MOVWF  2A
....................          } 
....................    } 
0E19:  GOTO   5E4
....................    k=0; 
0E1A:  CLRF   2A
....................    c=0; 
0E1B:  CLRF   60
....................    //lcd_putc("\f"); 
....................    lcd_putc(" / "); 
0E1C:  MOVLW  63
0E1D:  BSF    03.6
0E1E:  MOVWF  0D
0E1F:  MOVLW  00
0E20:  MOVWF  0F
0E21:  BCF    0A.3
0E22:  BCF    03.6
0E23:  CALL   187
0E24:  BSF    0A.3
.................... while(k!='#') 
....................    { 
0E25:  MOVF   2A,W
0E26:  SUBLW  23
0E27:  BTFSC  03.2
0E28:  GOTO   65B
....................       k=kbd_getc(); 
0E29:  BCF    0A.3
0E2A:  CALL   1C5
0E2B:  BSF    0A.3
0E2C:  MOVF   78,W
0E2D:  MOVWF  2A
....................       if(k!=0) 
0E2E:  MOVF   2A,F
0E2F:  BTFSC  03.2
0E30:  GOTO   65A
....................          { 
....................          if(k=='*') 
0E31:  MOVF   2A,W
0E32:  SUBLW  2A
0E33:  BTFSS  03.2
0E34:  GOTO   645
....................          { 
....................          k='.'; 
0E35:  MOVLW  2E
0E36:  MOVWF  2A
....................          rep[c]=k; 
0E37:  MOVLW  53
0E38:  ADDWF  60,W
0E39:  MOVWF  04
0E3A:  BCF    03.7
0E3B:  MOVF   2A,W
0E3C:  MOVWF  00
....................          c++; 
0E3D:  INCF   60,F
....................          printf(lcd_putc, "%c",k); 
0E3E:  MOVF   2A,W
0E3F:  BSF    03.5
0E40:  MOVWF  28
0E41:  BCF    0A.3
0E42:  BCF    03.5
0E43:  CALL   156
0E44:  BSF    0A.3
....................          } 
....................            if(k!='#'){  
0E45:  MOVF   2A,W
0E46:  SUBLW  23
0E47:  BTFSC  03.2
0E48:  GOTO   658
....................            rep[c]=k; 
0E49:  MOVLW  53
0E4A:  ADDWF  60,W
0E4B:  MOVWF  04
0E4C:  BCF    03.7
0E4D:  MOVF   2A,W
0E4E:  MOVWF  00
....................             c++; 
0E4F:  INCF   60,F
....................             printf(lcd_putc, "%c",k); 
0E50:  MOVF   2A,W
0E51:  BSF    03.5
0E52:  MOVWF  28
0E53:  BCF    0A.3
0E54:  BCF    03.5
0E55:  CALL   156
0E56:  BSF    0A.3
....................            } 
....................            else k = '#'; 
0E57:  GOTO   65A
0E58:  MOVLW  23
0E59:  MOVWF  2A
....................          } 
....................    } 
0E5A:  GOTO   625
....................    lcd_putc("\f"); 
0E5B:  MOVLW  65
0E5C:  BSF    03.6
0E5D:  MOVWF  0D
0E5E:  MOVLW  00
0E5F:  MOVWF  0F
0E60:  BCF    0A.3
0E61:  BCF    03.6
0E62:  CALL   187
0E63:  BSF    0A.3
....................    value=strtoul(num,&ptr,10); 
0E64:  CLRF   72
0E65:  MOVLW  3F
0E66:  MOVWF  71
0E67:  CLRF   74
0E68:  MOVLW  5D
0E69:  MOVWF  73
0E6A:  MOVLW  0A
0E6B:  MOVWF  75
0E6C:  BCF    0A.3
0E6D:  CALL   273
0E6E:  BSF    0A.3
0E6F:  MOVF   79,W
0E70:  MOVWF  68
0E71:  MOVF   78,W
0E72:  MOVWF  67
....................    value2 =strtod(rep,&ptr2); 
0E73:  CLRF   72
0E74:  MOVLW  53
0E75:  MOVWF  71
0E76:  CLRF   74
0E77:  MOVLW  5F
0E78:  MOVWF  73
0E79:  CALL   000
0E7A:  MOVF   7A,W
0E7B:  MOVWF  6C
0E7C:  MOVF   79,W
0E7D:  MOVWF  6B
0E7E:  MOVF   78,W
0E7F:  MOVWF  6A
0E80:  MOVF   77,W
0E81:  MOVWF  69
....................    d = value / value2; 
0E82:  MOVF   68,W
0E83:  BSF    03.5
0E84:  MOVWF  2C
0E85:  BCF    03.5
0E86:  MOVF   67,W
0E87:  BSF    03.5
0E88:  MOVWF  2B
0E89:  BCF    0A.3
0E8A:  BCF    03.5
0E8B:  CALL   4FA
0E8C:  BSF    0A.3
0E8D:  MOVF   7A,W
0E8E:  BSF    03.5
0E8F:  MOVWF  2E
0E90:  MOVF   79,W
0E91:  MOVWF  2D
0E92:  MOVF   78,W
0E93:  MOVWF  2C
0E94:  MOVF   77,W
0E95:  MOVWF  2B
0E96:  BCF    03.5
0E97:  MOVF   6C,W
0E98:  BSF    03.5
0E99:  MOVWF  32
0E9A:  BCF    03.5
0E9B:  MOVF   6B,W
0E9C:  BSF    03.5
0E9D:  MOVWF  31
0E9E:  BCF    03.5
0E9F:  MOVF   6A,W
0EA0:  BSF    03.5
0EA1:  MOVWF  30
0EA2:  BCF    03.5
0EA3:  MOVF   69,W
0EA4:  BSF    03.5
0EA5:  MOVWF  2F
0EA6:  BCF    0A.3
0EA7:  BCF    03.5
0EA8:  CALL   519
0EA9:  BSF    0A.3
0EAA:  MOVF   7A,W
0EAB:  MOVWF  70
0EAC:  MOVF   79,W
0EAD:  MOVWF  6F
0EAE:  MOVF   78,W
0EAF:  MOVWF  6E
0EB0:  MOVF   77,W
0EB1:  MOVWF  6D
....................    lcd_putc("La division es: "); 
0EB2:  MOVLW  66
0EB3:  BSF    03.6
0EB4:  MOVWF  0D
0EB5:  MOVLW  00
0EB6:  MOVWF  0F
0EB7:  BCF    0A.3
0EB8:  BCF    03.6
0EB9:  CALL   187
0EBA:  BSF    0A.3
....................    lcd_gotoxy(1,2); 
0EBB:  MOVLW  01
0EBC:  BSF    03.5
0EBD:  MOVWF  29
0EBE:  MOVLW  02
0EBF:  MOVWF  2A
0EC0:  BCF    0A.3
0EC1:  BCF    03.5
0EC2:  CALL   142
0EC3:  BSF    0A.3
....................    printf(lcd_putc, "%f",d); 
0EC4:  MOVLW  89
0EC5:  MOVWF  04
0EC6:  MOVF   70,W
0EC7:  MOVWF  74
0EC8:  MOVF   6F,W
0EC9:  MOVWF  73
0ECA:  MOVF   6E,W
0ECB:  MOVWF  72
0ECC:  MOVF   6D,W
0ECD:  MOVWF  71
0ECE:  MOVLW  02
0ECF:  MOVWF  75
0ED0:  CALL   143
....................    delay_ms(2000); 
0ED1:  MOVLW  08
0ED2:  MOVWF  71
0ED3:  MOVLW  FA
0ED4:  BSF    03.5
0ED5:  MOVWF  29
0ED6:  BCF    0A.3
0ED7:  BCF    03.5
0ED8:  CALL   08C
0ED9:  BSF    0A.3
0EDA:  DECFSZ 71,F
0EDB:  GOTO   6D3
....................    
....................    
....................    
....................    
....................  break; 
0EDC:  GOTO   6DE
.................... } 
....................  
.................... default: 
.................... break; 
0EDD:  GOTO   6DE
.................... } 
.................... c=0;k=0; 
0EDE:  CLRF   60
0EDF:  CLRF   2A
.................... lcd_gotoxy(1,1); 
0EE0:  MOVLW  01
0EE1:  BSF    03.5
0EE2:  MOVWF  29
0EE3:  MOVWF  2A
0EE4:  BCF    0A.3
0EE5:  BCF    03.5
0EE6:  CALL   142
0EE7:  BSF    0A.3
....................  lcd_putc("U wanna continue? "); 
0EE8:  MOVLW  6F
0EE9:  BSF    03.6
0EEA:  MOVWF  0D
0EEB:  MOVLW  00
0EEC:  MOVWF  0F
0EED:  BCF    0A.3
0EEE:  BCF    03.6
0EEF:  CALL   187
0EF0:  BSF    0A.3
....................   lcd_gotoxy(1,2); 
0EF1:  MOVLW  01
0EF2:  BSF    03.5
0EF3:  MOVWF  29
0EF4:  MOVLW  02
0EF5:  MOVWF  2A
0EF6:  BCF    0A.3
0EF7:  BCF    03.5
0EF8:  CALL   142
0EF9:  BSF    0A.3
....................  lcd_putc("Yes=1  No=2");  
0EFA:  MOVLW  79
0EFB:  BSF    03.6
0EFC:  MOVWF  0D
0EFD:  MOVLW  00
0EFE:  MOVWF  0F
0EFF:  BCF    0A.3
0F00:  BCF    03.6
0F01:  CALL   187
0F02:  BSF    0A.3
....................  while(c!=1){ 
0F03:  DECFSZ 60,W
0F04:  GOTO   706
0F05:  GOTO   711
.................... value3=kbd_getc(); 
0F06:  BCF    0A.3
0F07:  CALL   1C5
0F08:  BSF    0A.3
0F09:  MOVF   78,W
0F0A:  MOVWF  62
.................... if (value3 != 0){ 
0F0B:  MOVF   62,F
0F0C:  BTFSC  03.2
0F0D:  GOTO   710
....................    c=1; 
0F0E:  MOVLW  01
0F0F:  MOVWF  60
....................  
.................... } 
.................... } 
0F10:  GOTO   703
.................... lcd_putc("\f"); 
0F11:  MOVLW  7F
0F12:  BSF    03.6
0F13:  MOVWF  0D
0F14:  MOVLW  00
0F15:  MOVWF  0F
0F16:  BCF    0A.3
0F17:  BCF    03.6
0F18:  CALL   187
0F19:  BSF    0A.3
.................... if(value3 == '1') 
0F1A:  MOVF   62,W
0F1B:  SUBLW  31
0F1C:  BTFSS  03.2
0F1D:  GOTO   733
.................... { 
.................... lcd_putc("Ok, once again."); 
0F1E:  MOVLW  80
0F1F:  BSF    03.6
0F20:  MOVWF  0D
0F21:  MOVLW  00
0F22:  MOVWF  0F
0F23:  BCF    0A.3
0F24:  BCF    03.6
0F25:  CALL   187
0F26:  BSF    0A.3
.................... delay_ms(1000); 
0F27:  MOVLW  04
0F28:  MOVWF  71
0F29:  MOVLW  FA
0F2A:  BSF    03.5
0F2B:  MOVWF  29
0F2C:  BCF    0A.3
0F2D:  BCF    03.5
0F2E:  CALL   08C
0F2F:  BSF    0A.3
0F30:  DECFSZ 71,F
0F31:  GOTO   729
.................... } 
.................... else{ 
0F32:  GOTO   749
.................... lcd_putc("BYE."); 
0F33:  MOVLW  88
0F34:  BSF    03.6
0F35:  MOVWF  0D
0F36:  MOVLW  00
0F37:  MOVWF  0F
0F38:  BCF    0A.3
0F39:  BCF    03.6
0F3A:  CALL   187
0F3B:  BSF    0A.3
.................... delay_ms(1000); 
0F3C:  MOVLW  04
0F3D:  MOVWF  71
0F3E:  MOVLW  FA
0F3F:  BSF    03.5
0F40:  MOVWF  29
0F41:  BCF    0A.3
0F42:  BCF    03.5
0F43:  CALL   08C
0F44:  BSF    0A.3
0F45:  DECFSZ 71,F
0F46:  GOTO   73E
.................... z=1; 
0F47:  MOVLW  01
0F48:  MOVWF  61
.................... }  
....................   
....................       lcd_putc("\f"); 
0F49:  MOVLW  8B
0F4A:  BSF    03.6
0F4B:  MOVWF  0D
0F4C:  MOVLW  00
0F4D:  MOVWF  0F
0F4E:  BCF    0A.3
0F4F:  BCF    03.6
0F50:  CALL   187
0F51:  BSF    0A.3
....................       value = 0; 
0F52:  CLRF   68
0F53:  CLRF   67
....................       value2 =0; 
0F54:  CLRF   6C
0F55:  CLRF   6B
0F56:  CLRF   6A
0F57:  CLRF   69
....................       value3=0; 
0F58:  CLRF   62
.................... } 
0F59:  GOTO   26E
....................    //printf(lcd_putc,"%s-->",num); 
....................    //convert the string to value 
....................     
....................  
....................  
....................  
....................     
.................... } 
....................  
0F5A:  SLEEP

Configuration Fuses:
   Word  1: 3F73   RC NOWDT PUT NODEBUG NOPROTECT BROWNOUT NOLVP NOCPD NOWRT
